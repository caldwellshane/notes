# AUTOGENERATED! DO NOT EDIT! File to edit: src/core.pauli.ipynb (unless otherwise specified).

__all__ = ['pauli_matrices', 'pauli_names', 'PauliOperator']

# Cell

from functools import cache
from typing import Tuple

import numpy as np

# Cell

"""Definition of the Pauli matrices."""
pauli_matrices = (
    np.identity(2),
    np.array([[0, 1], [1, 0]]),
    np.array([[0, -1j], [1j, 0]]),
    np.array([[1, 0], [0, -1]]),
)

pauli_names = ("I", "X", "Y", "Z")

# Cell

class PauliOperator(tuple):
    """
    Multi-qubit Pauli operator.

    The operator acts on a basis whose dimensions are indexed by self.indices. When written as
    a tensor product, the lowest index is on the right, corresponding to the least significant
    digit in a bitstring.

    This class is implemented as a subclass of `tuple` so the we get access to all the nice
    methods and total ordering of tuples. Here we reverse the ordering of `tuple`.
    """
    def __init__(self, indices: Tuple[int, ...]):
        """
        Initialize the operation from the indices of each Pauli matrix.

        index 0 = I
        index 1 = X
        index 2 = Y
        index 3 = Z
        """
        if any([idx not in {0, 1, 2, 3} for idx in indices]):
            raise ValueError(f"All indices must be in {{0, 1, 2, 3}}.")
        self.dim = 2 ** len(indices)

    def __lt__(self, other):
        _check_pauli_operator_for_comparison(other)
        return super().__gt__(other)

    def __gt__(self, other):
        _check_pauli_operator_for_comparison(other)
        return super().__lt__(other)

    def __le__(self, other):
        _check_pauli_operator_for_comparison(other)
        return super().__ge__(other)

    def __ge__(self, other):
        _check_pauli_operator_for_comparison(other)
        return super().__le__(other)

    @property
    @cache
    def matrix(self):
        """
        Calculate and cache the matrix representation of this Pauli. Subsequent calls to
        """
        if len(self) > 16:
            raise ValueError(
                "Good grief, this is a didactic exercise. We won't allocate more than "
                f"16 qubits ({len(self)} requested).")
        return reduce(
            lambda x, y: np.kron(x, y),
            reversed(
                list(
                    map(
                        lambda idx: pauli_matrices[idx],
                        self
                    )
                )
            )
        )

    @staticmethod
    def name(indices: Tuple[int, ...]) -> str:
        """
        Compute the name of a PauliOperator with given indices. Note the written operator
        has the lowest index on the right.

        Example: indices (1, 3) -> "ZX"
        """
        return "".join(map(lambda x: pauli_names[x], reversed(indices)))

    def __repr__(self):
        return "PauliOperator " + "".join(map(lambda x: pauli_names[x], reversed(self)))

    def __str__(self):
        return self.name(self)


def _check_pauli_operator_for_comparison(other):
    if not isinstance(other, PauliOperator):
        raise TypeError(
            f"PauliOperator comparison is only supported with another PauliOperator, but "
            f"comparison to {type(other)} was requested."
        )