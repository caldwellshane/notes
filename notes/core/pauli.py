# AUTOGENERATED! DO NOT EDIT! File to edit: src/core.pauli.ipynb (unless otherwise specified).

__all__ = ['pauli_matrices', 'pauli_names', 'PauliOperator']

# Cell

from functools import cache, reduce, total_ordering
from typing import Tuple

import numpy as np

# Cell

"""Definition of the Pauli matrices."""
pauli_matrices = (
    np.identity(2),
    np.array([[0, 1], [1, 0]]),
    np.array([[0, -1j], [1j, 0]]),
    np.array([[1, 0], [0, -1]]),
)

pauli_names = ("I", "X", "Y", "Z")

# Cell

@total_ordering
class PauliOperator:
    """
    Multi-qubit Pauli operator.

    The operator acts on a basis whose dimensions are indexed by self.indices. When written as
    a tensor product, the lowest index is on the right, corresponding to the least significant
    digit in a bitstring.

    This class is implemented as a subclass of `tuple` so the we get access to all the nice
    methods and total ordering of tuples. Here we reverse the ordering of `tuple`.
    """
    def __init__(self, indices: Tuple[int, ...]):
        """
        Initialize the operation from the indices of each Pauli matrix.

        index 0 = I
        index 1 = X
        index 2 = Y
        index 3 = Z
        """
        if any([idx not in {0, 1, 2, 3} for idx in indices]):
            raise ValueError(f"All indices must be in {{0, 1, 2, 3}}.")
        self.dim = 2 ** len(indices)
        self.indices = indices

    def __hash__(self):
        return hash(self.indices)

    def __eq__(self, other):
        _check_pauli_operator_for_comparison(other)
        return self.indices == other.indices

    def __lt__(self, other):
        _check_pauli_operator_for_comparison(other)
        _check_paulis_same_dimension(self, other)
        return PauliOperator.integer_index(self.indices) < PauliOperator.integer_index(other.indices)

    @property
    @cache
    def matrix(self):
        """
        Calculate and cache the matrix representation of this Pauli. Subsequent calls to
        """
        if len(self.indices) > 16:
            raise ValueError(
                "Good grief, this is a didactic exercise. We won't allocate more than "
                f"16 qubits ({len(self.indices)} requested).")
        return reduce(
            lambda x, y: np.kron(x, y),
            reversed(
                list(
                    map(
                        lambda idx: pauli_matrices[idx],
                        self.indices
                    )
                )
            )
        )

    @staticmethod
    def integer_index(indices: Tuple[int, ...]) -> int:
        """Compute the single-integer index corresponding to the given tuple indices."""
        return sum((pauli_index * 4**position for position, pauli_index in enumerate(indices)))

    @staticmethod
    def name_from_indices(indices: Tuple[int, ...]) -> str:
        """
        Compute the name of a PauliOperator with given indices. Note the written operator
        has the lowest index on the right.

        Example: indices (1, 3) -> "ZX"
        """
        return "".join(map(lambda x: pauli_names[x], reversed(indices)))

    @property
    def name(self) -> str:
        return self.name_from_indices(self.indices)

    def __repr__(self):
        return "PauliOperator " + self.name

    def __str__(self):
        return self.name


def _check_pauli_operator_for_comparison(other) -> None:
    """Raise if `other` is not a `PauliOperator`."""
    if not isinstance(other, PauliOperator):
        raise TypeError(
            f"PauliOperator comparison is only supported with another PauliOperator, but "
            f"comparison to {type(other)} was requested."
        )


def _check_paulis_same_dimension(pauli_1: PauliOperator, pauli_2: PauliOperator) -> None:
    """Raise if `pauli_1` and `pauli_2` have different dimensions."""
    if pauli_1.dim != pauli_2.dim:
        raise ValueError()