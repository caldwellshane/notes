# AUTOGENERATED! DO NOT EDIT! File to edit: src/tomography.ipynb (unless otherwise specified).

__all__ = ['computational_to_pauli_state', 'pauli_to_computational_state', 'paulis_for_num_qubits',
           'pauli_transfer_matrix_unitary', 'QuantumGate']

# Cell

from functools import cache
from typing import List, Tuple

from bokeh.palettes import palettes
from bokeh.plotting import figure, show, output_notebook
from nbdev.imports import *
from nbdev.showdoc import *
from scipy.linalg import expm

import numpy as np
# import plotly.graph_objects as go

output_notebook()

# Cell

_comp_to_pauli_matrix = 0.5 * np.array(
    [
        [1, 0, 0, 1],
        [0, 1, 1, 0],
        [0, 1j, -1j, 0],
        [1, 0, 0, -1],
    ]
)
_pauli_to_comp_matrix = np.array(
    [
        [1, 0, 0, 1],
        [0, 1, -1j, 0],
        [0, 1, 1j, 0],
        [1, 0, 0, -1],
    ]
)


def computational_to_pauli_state(density_mat: np.ndarray) -> np.ndarray:
    """Convert a density matrix in the computational basis """
    if np.shape(density_mat) == (4, ):
        return np.matmul(density_mat, _comp_to_pauli_matrix.T)
    elif np.shape(density_mat) == (4, 1):
        return np.matmul(_comp_to_pauli_matrix, density_mat)
    elif np.shape(density_mat) == (2, 2):
        return np.matmul(_comp_to_pauli_matrix, density_mat.reshape((4, 1))).reshape((2, 2))
    else:
        raise TypeError(f"density_mat has wrong shape {np.shape(density_mat)}")

def pauli_to_computational_state(density_mat: np.ndarray):
    if np.shape(density_mat) == (4, ):
        return np.matmul(density_mat, _pauli_to_comp_matrix.T)
    elif np.shape(density_mat) == (4, 1):
        return np.matmul(_pauli_to_comp_matrix, density_mat)
    elif np.shape(density_mat) == (2, 2):
        return np.matmul(_pauli_to_comp_matrix, density_mat.reshape((4, 1))).reshape((2, 2))
    else:
        raise TypeError(f"density_mat has wrong shape {np.shape(density_mat)}")

# Cell

from .core.pauli import pauli_matrices as σ, pauli_names, PauliOperator


def paulis_for_num_qubits(num_qubits: int) -> List[PauliOperator]:
    return sorted(
        [PauliOperator(idxs) for idxs in itertools.product(range(4), repeat=num_qubits)]
    )


def pauli_transfer_matrix_unitary(unitary: np.ndarray) -> np.ndarray:
    """Compute the Pauli Transfer Matrix for the given unitary matrix."""
    dim = len(unitary)
    num_qubits = int(np.log2(dim))
    paulis = paulis_for_num_qubits(num_qubits)
    return np.real(
            np.array(
                [
                    [
                        np.trace(σj.matrix @ unitary @ σi.matrix @ unitary.conj().T)
                    for σj in paulis]
                for σi in paulis]
            )
        ) / dim


class QuantumGate:

    def __init__(self, computational_basis: List[Tuple], unitary_matrix: np.ndarray):
        self.computational_basis = computational_basis
        self.unitary_matrix = unitary_matrix
        self.dim = np.shape(unitary_matrix)[0]

    @property
    @cache
    def chi_matrix(self):
        """
        Compute the chi matrix representation of the gate.

        See Nielsen and Chuang, Quantum Computation and Quantum Information, 10th Anniversary Ed.,
        p. 391.
        """
        raise NotImplementedError

    @property
    @cache
    def pauli_transfer_matrix(self):
        return pauli_transfer_matrix_unitary(self.unitary_matrix)